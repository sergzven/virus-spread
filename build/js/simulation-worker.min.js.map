{"version":3,"sources":["simulation-worker.min.js"],"names":["lineLength","line","Math","sqrt","pow","pointTranslate","point","angle","distance","r","angleToRadians","cos","sin","PI","lineAngle","angleToDegrees","atan2","angleReflect","incidenceAngle","surfaceAngle","a","pointLeftOfLine","t","topPointFirst","cross","b","o","lineMidpoint","lineInterpolate","closestPoint","best","bestLength","scan","scanDistance","length","interpolator","precision","bestDistance","Infinity","scanLength","distance2","before","after","beforeLength","afterLength","beforeDistance","afterDistance","pctBefore","pctAfter","p","dx","dy","tick","simulation","TOTAL_TICKS","ticks","updateWalls","gap","gapScale","height","walls","makeGap","data","forEach","d","infected","ticksToRecover","timeAtInfection","recovered","sick","filter","f","lastSick","lastRecovered","storage","push","well","i","collided","i0","d0","pos","radius","speed","dc","JSON","parse","stringify","transferEnergy","wall","projPoint","newAngle","width","t0","l0","center","reflected","t1","rangeDistance","output","onmessage","e","totalTicksRemaining","countdown","map","currTicks","postMessage"],"mappings":"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","file":"simulation-worker.min.js","sourcesContent":["onmessage = function(e){\r\n  const [data, TOTAL_TICKS, totalTicksRemaining] = e.data;\r\n  let countdown = totalTicksRemaining;\r\n  \r\n  data.map(d => {\r\n    let output;\r\n    const currTicks = d.data.ticks;\r\n    if (currTicks < TOTAL_TICKS){\r\n      for (let i = currTicks; i < TOTAL_TICKS; i++){\r\n        output = tick(d.data, TOTAL_TICKS);\r\n        postMessage(countdown--);\r\n      }\r\n    }\r\n    else {\r\n      output = d.data;\r\n    }\r\n    return output;\r\n  });\r\n  \r\n  postMessage(data);\r\n}\r\n\r\n// Can't require in web workers, so all the functions are here\r\nfunction lineLength(line){\r\n  return Math.sqrt(Math.pow(line[1][0] - line[0][0], 2) + Math.pow(line[1][1] - line[0][1], 2));\r\n}\r\n\r\nfunction pointTranslate(point, angle, distance){\r\n  const r = angleToRadians(angle);\r\n  return [point[0] + distance * Math.cos(r), point[1] + distance * Math.sin(r)];\r\n}\r\n\r\nfunction angleToRadians(angle){\r\n  return angle / 180 * Math.PI;\r\n}\r\n\r\nfunction lineAngle(line){\r\n  return angleToDegrees(Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]));\r\n}\r\n\r\nfunction angleReflect(incidenceAngle, surfaceAngle){\r\n  const a = surfaceAngle * 2 - incidenceAngle;\r\n  return a >= 360 ? a - 360 : a < 0 ? a + 360 : a;\r\n}\r\n\r\nfunction angleToDegrees(angle){\r\n  return angle * 180 / Math.PI;\r\n}\r\n\r\nfunction pointLeftOfLine(point, line){\r\n  const t = topPointFirst(line);\r\n  return cross(point, t[1], t[0]) < 0;\r\n}\r\n\r\nfunction topPointFirst(line){\r\n  return line[1][1] > line[0][1] ? line : [line[1], line[0]];\r\n}\r\n\r\nfunction cross (a, b, o){\r\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\r\n}\r\n\r\nfunction lineMidpoint(line){\r\n  return [(line[0][0] + line[1][0]) / 2, (line[0][1] + line[1][1]) / 2];\r\n}\r\n\r\nfunction lineInterpolate(line){\r\n  return t => t === 0 ? line[0] : t === 1 ? line[1] : pointTranslate(line[0], lineAngle(line), lineLength(line) * t);\r\n}\r\n\r\nfunction closestPoint(point, line) {\r\n  var length = lineLength(line),\r\n    interpolator = lineInterpolate(line),\r\n    precision = 8,\r\n    best,\r\n    bestLength,\r\n    bestDistance = Infinity;\r\n  \r\n  // linear scan for coarse approximation\r\n  for (var scan, scanLength = 0, scanDistance; scanLength <= length; scanLength += precision) {\r\n    const pct = scanLength / length;\r\n    if ((scanDistance = distance2(scan = interpolator(pct))) < bestDistance) {\r\n      best = scan, bestLength = scanLength, bestDistance = scanDistance;\r\n    }\r\n  }\r\n  \r\n  // binary search for precise estimate\r\n  precision /= 2;\r\n  while (precision > 0.5) {\r\n    var before,\r\n      after,\r\n      beforeLength,\r\n      afterLength,\r\n      beforeDistance,\r\n      afterDistance;\r\n    \r\n    const pctBefore = beforeLength / length, pctAfter = afterLength / length;\r\n    if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = interpolator(pctBefore))) < bestDistance) {\r\n      best = before, bestLength = beforeLength, bestDistance = beforeDistance;\r\n    } else if ((afterLength = bestLength + precision) <= length && (afterDistance = distance2(after = interpolator(pctAfter) )) < bestDistance) {\r\n      best = after, bestLength = afterLength, bestDistance = afterDistance;\r\n    } else {\r\n      precision /= 2;\r\n    }\r\n  }\r\n  \r\n  return best;\r\n  \r\n  function distance2(p) {\r\n    var dx = p[0] - point[0],\r\n      dy = p[1] - point[1];\r\n    return dx * dx + dy * dy;\r\n  }\r\n}\r\n\r\nfunction tick(simulation, TOTAL_TICKS){\r\n  simulation.ticks++;\r\n  \r\n  // Update the walls\r\n  if (simulation.updateWalls){\r\n    const gap = gapScale(simulation.ticks, TOTAL_TICKS, simulation.height);\r\n    simulation.walls = makeGap(simulation, gap);\r\n  }\r\n  \r\n  // See who's cured\r\n  simulation.data.forEach(d => {\r\n    if (d.infected){\r\n      if (simulation.ticksToRecover < simulation.ticks - d.timeAtInfection){\r\n        d.infected = false;\r\n        d.recovered = true;\r\n        d.timeAtInfection = null;\r\n      }\r\n    }\r\n  });\r\n  \r\n  const sick = simulation.data.filter(f => f.infected).length;\r\n  const recovered = simulation.data.filter(f => f.recovered).length;\r\n  const noChange = sick === simulation.lastSick && recovered === simulation.lastRecovered;\r\n  \r\n  // If there has been no change in the number of sick,\r\n  // simply update the previous tick\r\n  if (noChange && simulation.storage.length){\r\n    simulation.storage[simulation.storage.length - 1].tick++;\r\n  }\r\n  // Otherwise add a new datum\r\n  else {\r\n    simulation.storage.push({tick: simulation.ticks, sick, recovered, well: simulation.data.length - sick - recovered});\r\n  }\r\n  \r\n  // Loop through the data\r\n  for (let i = 0; i < simulation.data.length; i++){\r\n    const d = simulation.data[i];\r\n    d.collided = false;\r\n    \r\n    // Detect collisions\r\n    for (let i0 = 0; i0 < simulation.data.length; i0++){\r\n      const d0 = simulation.data[i0];\r\n      d0.collided = false;\r\n      \r\n      // Collision!\r\n      if (i !== i0 && lineLength([d.pos, d0.pos]) < d.radius + d0.radius && !d.collided && !d0.collided){\r\n        \r\n        // Test if moving them in each other's angles will bring them closer or farther apart\r\n        const keep0 = pointTranslate(d.pos, d.angle, d.speed),\r\n          keep1 = pointTranslate(d0.pos, d0.angle, d0.speed),\r\n          keep = lineLength([keep0, keep1]),\r\n          change0 = pointTranslate(d.pos, d0.angle, d0.speed),\r\n          change1 = pointTranslate(d0.pos, d.angle, d.speed),\r\n          change = lineLength([change0, change1]);\r\n        \r\n        if (keep < change) {\r\n          const dc = JSON.parse(JSON.stringify(d));\r\n          \r\n          if (simulation.transferEnergy){\r\n            d.angle = d0.angle;\r\n            d0.angle = dc.angle;\r\n            d.speed = d0.speed;\r\n            d0.speed = dc.speed;\r\n          }\r\n          \r\n          else {\r\n            if (d.speed && d0.speed){\r\n              d.angle = d0.angle;\r\n              d0.angle = dc.angle;\r\n            }\r\n            else {\r\n              d.angle = angleReflect(d.angle, -d.angle);\r\n              d0.angle = angleReflect(d0.angle, -d0.angle);\r\n            }\r\n            \r\n          }\r\n          \r\n          // Whether to infect each other\r\n          if (d.infected && !d0.infected && !d0.recovered) {\r\n            d0.infected = true;\r\n            d0.timeAtInfection = simulation.ticks;\r\n          }\r\n          \r\n          if (d0.infected && !d.infected && !d.recovered) {\r\n            d.infected = true;\r\n            d.timeAtInfection = simulation.ticks;\r\n          }\r\n          \r\n          d.collided = true;\r\n          d0.collided = true;\r\n        }\r\n        \r\n        break;\r\n      }\r\n    }\r\n    \r\n    // Detect custom walls\r\n    for (let i0 = 0; i0 < simulation.walls.length; i0++){\r\n      const wall = simulation.walls[i0],\r\n        projPoint = pointTranslate(d.pos, lineAngle([d.pos, closestPoint(d.pos, wall)]), d.radius),\r\n        pointLeft = pointLeftOfLine(d.pos, wall),\r\n        projLeft = pointLeftOfLine(projPoint, wall);\r\n      \r\n      // Flip it\r\n      if (pointLeft !== projLeft) {\r\n        \r\n        // Need some logic so that it doesn't get stuck on the wall\r\n        const newAngle = angleReflect(d.angle, lineAngle(wall)),\r\n          newPos = pointTranslate(d.pos, newAngle, d.speed),\r\n          midpoint = lineMidpoint(wall);\r\n        \r\n        // If the nowPos is closer to the wall's midpoint, don't change the angle\r\n        // if (lineLength([newPos, midpoint]) < lineLength([d.pos, midpoint])){\r\n        d.angle = newAngle;\r\n        // }\r\n      }\r\n      \r\n    }\r\n    \r\n    // Detect outer walls\r\n    if (d.pos[0] <= d.radius || d.pos[0] >= simulation.width - d.radius){\r\n      \r\n      // Is it moving more towards the middle or not\r\n      const t0 = pointTranslate(d.pos, d.angle, d.speed);\r\n      const l0 = lineLength([simulation.center, t0]);\r\n      \r\n      const reflected = angleReflect(d.angle, 90);\r\n      const t1 = pointTranslate(d.pos, reflected, d.speed);\r\n      const l1 = lineLength([simulation.center, t1]);\r\n      \r\n      if (l1 < l0) d.angle = reflected;\r\n    }\r\n    \r\n    // Detect vertical walls\r\n    if (d.pos[1] <= d.radius || d.pos[1] >= simulation.height - d.radius){\r\n      // Is it moving more towards the middle or not\r\n      const t0 = pointTranslate(d.pos, d.angle, d.speed);\r\n      const l0 = lineLength([simulation.center, t0]);\r\n      \r\n      const reflected = angleReflect(d.angle, 0);\r\n      const t1 = pointTranslate(d.pos, reflected, d.speed);\r\n      const l1 = lineLength([simulation.center, t1]);\r\n      \r\n      if (l1 < l0) d.angle = reflected;\r\n    }\r\n    \r\n    d.pos = pointTranslate(d.pos, d.angle, d.speed);\r\n  }\r\n  \r\n  return simulation;\r\n}\r\n\r\n// Have to write my own scale linear\r\nfunction gapScale(ticks, TOTAL_TICKS, height){\r\n  const domainDistance = TOTAL_TICKS / 2 - TOTAL_TICKS / 6;\r\n  const domainPosition = (ticks - TOTAL_TICKS / 6) / domainDistance;\r\n  \r\n  const rangeDistance = height / 4;\r\n  const output = rangeDistance * domainPosition;\r\n  \r\n  return output < 0 ? 0 : output > rangeDistance ? rangeDistance : output;\r\n}\r\n\r\nfunction makeGap(simulation, gap){\r\n  return [\r\n    [\r\n      [simulation.width * .3 - 10, 0],\r\n      [simulation.width * .3 - 10, simulation.height * .5 - gap]\r\n    ],\r\n    [\r\n      [simulation.width * .3 + 10, 0],\r\n      [simulation.width * .3 + 10, simulation.height * .5 - gap]\r\n    ],\r\n    [\r\n      [simulation.width * .3 - 10, simulation.height * .5 - gap],\r\n      [simulation.width * .3 + 10, simulation.height * .5 - gap]\r\n    ],\r\n    [\r\n      [simulation.width * .3 - 10, simulation.height],\r\n      [simulation.width * .3 - 10, simulation.height * .5 + gap]\r\n    ],\r\n    [\r\n      [simulation.width * .3 + 10, simulation.height],\r\n      [simulation.width * .3 + 10, simulation.height * .5 + gap]\r\n    ],\r\n    [\r\n      [simulation.width * .3 - 10, simulation.height * .5 + gap],\r\n      [simulation.width * .3 + 10, simulation.height * .5 + gap]\r\n    ]\r\n  ];\r\n}"]}