function lineLength(e){return Math.sqrt(Math.pow(e[1][0]-e[0][0],2)+Math.pow(e[1][1]-e[0][1],2))}function pointTranslate(e,t,n){const i=angleToRadians(t);return[e[0]+n*Math.cos(i),e[1]+n*Math.sin(i)]}function angleToRadians(e){return e/180*Math.PI}function lineAngle(e){return angleToDegrees(Math.atan2(e[1][1]-e[0][1],e[1][0]-e[0][0]))}function angleReflect(e,t){const n=2*t-e;return n>=360?n-360:n<0?n+360:n}function angleToDegrees(e){return 180*e/Math.PI}function pointLeftOfLine(e,t){const n=topPointFirst(t);return cross(e,n[1],n[0])<0}function topPointFirst(e){return e[1][1]>e[0][1]?e:[e[1],e[0]]}function cross(e,t,n){return(e[0]-n[0])*(t[1]-n[1])-(e[1]-n[1])*(t[0]-n[0])}function lineMidpoint(e){return[(e[0][0]+e[1][0])/2,(e[0][1]+e[1][1])/2]}function lineInterpolate(e){return t=>0===t?e[0]:1===t?e[1]:pointTranslate(e[0],lineAngle(e),lineLength(e)*t)}function closestPoint(e,t){for(var n,i,a,l,o=lineLength(t),s=lineInterpolate(t),r=8,c=1/0,g=0;g<=o;g+=r){(l=T(a=s(g/o)))<c&&(n=a,i=g,c=l)}for(r/=2;r>.5;){var d,p,h,f,u,w;const e=h/o,t=f/o;(h=i-r)>=0&&(u=T(d=s(e)))<c?(n=d,i=h,c=u):(f=i+r)<=o&&(w=T(p=s(t)))<c?(n=p,i=f,c=w):r/=2}return n;function T(t){var n=t[0]-e[0],i=t[1]-e[1];return n*n+i*i}}function tick(e,t){if(e.ticks++,e.updateWalls){const n=gapScale(e.ticks,t,e.height);e.walls=makeGap(e,n)}e.data.forEach(t=>{t.infected&&e.ticksToRecover<e.ticks-t.timeAtInfection&&(t.infected=!1,t.recovered=!0,t.timeAtInfection=null)});const n=e.data.filter(e=>e.infected).length,i=e.data.filter(e=>e.recovered).length;n===e.lastSick&&i===e.lastRecovered&&e.storage.length?e.storage[e.storage.length-1].tick++:e.storage.push({tick:e.ticks,sick:n,recovered:i,well:e.data.length-n-i});for(let t=0;t<e.data.length;t++){const n=e.data[t];n.collided=!1;for(let i=0;i<e.data.length;i++){const a=e.data[i];if(a.collided=!1,t!==i&&lineLength([n.pos,a.pos])<n.radius+a.radius&&!n.collided&&!a.collided){if(lineLength([pointTranslate(n.pos,n.angle,n.speed),pointTranslate(a.pos,a.angle,a.speed)])<lineLength([pointTranslate(n.pos,a.angle,a.speed),pointTranslate(a.pos,n.angle,n.speed)])){const t=JSON.parse(JSON.stringify(n));e.transferEnergy?(n.angle=a.angle,a.angle=t.angle,n.speed=a.speed,a.speed=t.speed):n.speed&&a.speed?(n.angle=a.angle,a.angle=t.angle):(n.angle=angleReflect(n.angle,-n.angle),a.angle=angleReflect(a.angle,-a.angle)),!n.infected||a.infected||a.recovered||(a.infected=!0,a.timeAtInfection=e.ticks),!a.infected||n.infected||n.recovered||(n.infected=!0,n.timeAtInfection=e.ticks),n.collided=!0,a.collided=!0}break}}for(let t=0;t<e.walls.length;t++){const i=e.walls[t],a=pointTranslate(n.pos,lineAngle([n.pos,closestPoint(n.pos,i)]),n.radius);if(pointLeftOfLine(n.pos,i)!==pointLeftOfLine(a,i)){const e=angleReflect(n.angle,lineAngle(i));pointTranslate(n.pos,e,n.speed),lineMidpoint(i);n.angle=e}}if(n.pos[0]<=n.radius||n.pos[0]>=e.width-n.radius){const t=pointTranslate(n.pos,n.angle,n.speed),i=lineLength([e.center,t]),a=angleReflect(n.angle,90),l=pointTranslate(n.pos,a,n.speed);lineLength([e.center,l])<i&&(n.angle=a)}if(n.pos[1]<=n.radius||n.pos[1]>=e.height-n.radius){const t=pointTranslate(n.pos,n.angle,n.speed),i=lineLength([e.center,t]),a=angleReflect(n.angle,0),l=pointTranslate(n.pos,a,n.speed);lineLength([e.center,l])<i&&(n.angle=a)}n.pos=pointTranslate(n.pos,n.angle,n.speed)}return e}function gapScale(e,t,n){const i=n/4,a=i*((e-t/6)/(t/2-t/6));return a<0?0:a>i?i:a}function makeGap(e,t){return[[[.3*e.width-10,0],[.3*e.width-10,.5*e.height-t]],[[.3*e.width+10,0],[.3*e.width+10,.5*e.height-t]],[[.3*e.width-10,.5*e.height-t],[.3*e.width+10,.5*e.height-t]],[[.3*e.width-10,e.height],[.3*e.width-10,.5*e.height+t]],[[.3*e.width+10,e.height],[.3*e.width+10,.5*e.height+t]],[[.3*e.width-10,.5*e.height+t],[.3*e.width+10,.5*e.height+t]]]}onmessage=function(e){const[t,n,i]=e.data;let a=i;t.map(e=>{let t;const i=e.data.ticks;if(i<n)for(let l=i;l<n;l++)t=tick(e.data,n),postMessage(a--);else t=e.data;return t}),postMessage(t)};
//# sourceMappingURL=simulation-worker.min.js.map
